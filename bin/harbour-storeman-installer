#!/bin/sh
set -u  # Do not use "-f" (disable pathname expansion) and "-C" (no-clobber /
# -overwrite), as this script does not potentially need that (yet).
# Also drop "-e" for now, as it helps and hinders different aspects of debugging.
#set -o pipefail  # Not used (yet), hence also dropping interpreter #!/bin/bash
#export POSIXLY_CORRECT=1  # Leave it for now, can have side-effects (positive and negative), apparently not needed (yet).
export LC_ALL=POSIX  # For details see https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_02
export mypid="$$"
umask 7113  # The first octal digit is ignored by most implementations
cd /tmp  # Set PWD

# Specify bash as interpreter of this script (in its first line), as this ensures
# that "-o pipefail" is available (for its use in the third line), after checking
# that bash seems to be present in mer-core at least since 2011-10-04 (see
# https://github.com/sailfishos/mer-core/bash / https://git.merproject.org/mer-core/bash )
# and consequently in SailfishOS since its beginnings (checked v1.0.0.5 per
# curl https://releases.sailfishos.org/sources/sailfish-1.0.0.5-oss.tar.bz2 | tar -tv | fgrep bash
# , as no earlier released version is available there, e.g. the first ones at
# https://coderus.openrepos.net/whitesoft/sailversion ).
# In SailfishOS releases before 4.0, /bin/sh is just a symbolic link to /bin/bash
# anyway.  Since SailfishOS 4.0, the busybox variant of ash has become the shell
# installed by default, which provides some bash compatibility (implicitly, when
# called via its bash-symlink, which is deployed by the busybox-symlinks-bash
# RPM), including "-o pipefail", but not "-o posix"; although setting
# POSIXLY_CORRECT instead seems to achive the same without compatibility issues,
# plus (when exported) also for a number of other GNU utilities.
# Nevertheless, this script is still a Bourne (not-"Again") Shell script and
# shall stay free of bashisms.

# This script is designed to be called manually.

# Memorise how we were called:
called="$(basename "$0")"

export logfile="/var/log/${called}.log.txt"

# Prefix first output with three linebreaks, if logfile size > 0
linebreaks=""
if [ -s "$logfile" ]
then linebreaks="\n\n\n"
fi

# Even when started interactively, another pkcon job may have just been
# started, hence provide pkcon with a little time to enqueue it, because
# otherwise pkcon might fail enqueuing the next pkcon-job.
sleep 1
# `pkcon search name` is also intended to serve as a synchronisation point,
# because most of pkcon's sub-commands wait until the package management
# backend (on SailfishOS: libzypp) is idle:
pkgname="$(pkcon -p search name "$called" | grep '^Installed ' | tr -s ' ' | cut -f 2 -d ' ' | rev | cut -f 2- -d '.' | rev | grep -m 1 "^$called-[0-9]")"

# Write first entry to logfile:
logentry="[Info] $pkgname touch'ed $logfile"
if printf "${linebreaks}%s\n" "$(date -Iseconds) $logentry" >> "$logfile"
then printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 6 || true
systemd-cat -t "$called" -p 4 else printf '%s\n' "[Error] $pkgname failed to write to $logfile" || true
fi

# Out of occasional bad experience when pkcon is being hammered with
# commands, also prefix `pkcon repo-set-data` with a second sleep:
sleep 1
logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
maxi=5
maxihalf=$(expr $maxi / 2)
for i in $(seq -s ' ' $maxi)
do
  eval $logentry >> "$logfile" 2>&1
  retc=$?
  wait=$(expr $i \* 2 + 1)
  if [ $retc = 0 ]
  then break  # Went fine
  elif [ $i = 1 ]
  then
    logentry="[Warning] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 5 || true
    logentry="[Debug] Sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -le $maxihalf ]
  then
    logentry="[Warning] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 5 || true
    logentry="[Info] Trying to terminate (i.e., sending a "TERM" signal to) all processes named ("ID") `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
    killall -15 pkcon
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -lt $maxi ]
  then
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 4 || true
    logentry="[Warning] Trying to hang up  (i.e., sending a "HUP" signal to) all processes named ("ID") `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    killall -1 pkcon
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  else
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 4 || true
    logentry="[Warning] Trying to quit  (i.e., sending a "QUIT" signal to) all processes named ("ID") `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    killall -3 pkcon
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
    logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
    printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
    eval $logentry >> "$logfile" 2>&1 && break  # Was final try successful?
    logentry="[Critical] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 3 || true
    logentry="[Info] Trying to install harbour-storeman despite the failed repository refresh."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  fi
done
export logentry="pkcon -pvy install harbour-storeman"
printf '\n%s\n' "$(date -Iseconds) [Step 2 / 2] $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
# Sleeping again for a second right before the next pkcon call, because pkcon
# *rarely* fails installing a package ("not found") immediately after an
# individual repository refresh via `repo-set-data <repo> refresh-now true`.
# The following statement must be started fully detached ("double fork" /
# "daemonize": first a detached sub shell, in which pwd, umask might and
# session-id must be set anew (i.e., the execution environment), then again
# the command proper to run as new session-leader), because this script file
# will be removed in the process, which will likely fail, if it is still
# opened for executing / reading.
# It also shall always be the last command issued (WRT control-flow).
setsid --fork /bin/sh -c '(kill "$PPID"; sleep 1; i=0; while [ $i -lt 9 ] && ps -eo pid | grep -Fq "$mypid"; do sleep 1; i=$(expr $i + 1); done; eval $logentry >> "$logfile" 2>&1 < /dev/null) &' >> "$logfile" 2>&1 < /dev/null
# "Daemonizing" / double-forking ("SysV-style") in Shell code, (ab)using
# this interpreter instance as first fork.
# PWD and umask do not need to be set anew here, see line 9.
exit $retc

