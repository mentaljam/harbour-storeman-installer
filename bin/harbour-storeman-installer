#!/bin/sh
set -u  # Do not use "-f" (disable pathname expansion) and "-C" (no-clobber /
# -overwrite), as this script does not potentially need that (yet).
# Also drop "-e" for now, as it helps and hinders different aspects of debugging.
#set -o pipefail  # Not used (yet), hence also dropping interpreter #!/bin/bash
#export POSIXLY_CORRECT=1  # Leave it for now, can have side-effects (positive and negative), apparently not needed (yet).
export LC_ALL=POSIX  # For details see https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_02

# Specify bash as interpreter of this script (in its first line), as this ensures
# that "-o pipefail" is available (for its use in the third line), after checking
# that bash seems to be present in mer-core at least since 2011-10-04 (see
# https://github.com/sailfishos/mer-core/bash / https://git.merproject.org/mer-core/bash )
# and consequently in SailfishOS since its beginnings (checked v1.0.0.5 per
# curl https://releases.sailfishos.org/sources/sailfish-1.0.0.5-oss.tar.bz2 | tar -tv | fgrep bash
# , as no earlier released version is available there, e.g. the first ones at
# https://coderus.openrepos.net/whitesoft/sailversion ).
# In SailfishOS releases before 4.0, /bin/sh is just a symbolic link to /bin/bash
# anyway.  Since SailfishOS 4.0, the busybox variant of ash has become the shell
# installed by default, which provides some bash compatibility (implicitly, when
# called via its bash-symlink, which is deployed by the busybox-symlinks-bash
# RPM), including "-o pipefail", but not "-o posix"; although setting
# POSIXLY_CORRECT instead seems to achive the same without compatibility issues,
# plus (when exported) also for a number of other GNU utilities.
# Nevertheless, this script is still a Bourne (not-"Again") Shell script and
# shall stay free of bashisms.

# This script is designed to be started manually, either via GUI invoker (when
# a user taps on the desktop ("laucher") icon or directly (e.g., in a shell).

# Memorise how we were called:
mypid="$$"
called="$(basename "$0")"
logfile="/var/log/${called}.log.txt"

umask 7113  # The first octal digit is ignored by most implementations
[ "$PWD" = /tmp ] || cd /tmp  # Set PWD to /tmp

# Prefix first output with three linebreaks, if logfile size > 0
linebreaks=""
if [ -s "$logfile" ]
then linebreaks="\n\n------------------------------------------------------------------------------------------------------------\n\n\n"
fi

# Write first entry to logfile:
logentry="[Info] PID $mypid is logging to $logfile"
if printf "${linebreaks}%s\n" "$(date -Iseconds) $logentry" >> "$logfile"
then printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 6 || true
else systemd-cat -t "$called" -p 4 printf '%s\n' "[Warning] PID $mypid failed to write to $logfile" || true
fi

# Even when started interactively, another pkcon job may have just been
# started, hence provide pkcon with a little time to enqueue it, because
# otherwise pkcon might fail enqueuing the next pkcon-job.
sleep 1
# `pkcon search name` is also intended to serve as a synchronisation point,
# because most of pkcon's sub-commands wait until the package management
# backend (on SailfishOS: libzypp) is idle:
if pkgname="$(pkcon -p search name "$called" | grep '^Installed ' | tr -s ' ' | cut -f 2 -d ' ' | rev | cut -f 2- -d '.' | rev | grep -m 1 "^$called-[0-9]")"
then pkgkitd=ok
else pkgkitd=KO
fi

# Write $pkgname to logfile:
logentry="[Debug] Installed, now running: $pkgname"
printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true

# Out of occasional bad experience when pkcon is being hammered with
# commands, also prefix `pkcon repo-set-data` with a second sleep:
sleep 1
maxi=4  # 4 is the minimal value, which makes sense here
maxihalf=$(expr $maxi / 2)
for i in $(seq $maxi)
do
  logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
  printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
  systemd-cat -t "$called" -p 6 printf '%s\n' "[Info] Executing: $logentry" || true
  eval $logentry >> "$logfile" 2>&1
  retc=$?
  wait=$(expr $i \* 2 + 1)
  if [ $retc = 0 ]
  then break  # Went fine
  elif [ $i = 1 ]
  then
    logentry="[Notice] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 5 || true
    logentry="[Debug] Sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -le $maxihalf ]
  then
    logentry="[Warning] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 4 || true
    logentry="[Notice] Trying to terminate (i.e., sending SIGTERM to) all processes named (ID) `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 5 printf '%s\n' "$logentry" || true
    killall -q -TERM pkcon || true
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -lt $maxi ]
  then
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 3 || true
    logentry="[Warning] Trying to interrupt (i.e., sending SIGINT to) all processes named (ID) `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 4 printf '%s\n' "$logentry" || true
    killall -q -INT pkcon || true
    sleep $i
    killall -q -TERM pkcon || true
    sleep $i
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  else
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 3 || true
    logentry="[Warning] Trying to hang-up (i.e., sending SIGHUP to) all processes named (ID) `pkcon`, then sleeping for $i seconds and ultimately killing them."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 4 printf '%s\n' "$logentry" || true
    killall -q -HUP pkcon || true
    sleep $i
    killall -qw -KILL pkcon || true
    sleep 1
    systemctl stop packagekit.service || true
    sleep 1
    systemctl start packagekit.service || true
    sleep 1
    logentry="[Notice] Final retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 5 printf '%s\n' "$logentry" || true
    logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
    printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "[Info] Executing: $logentry" || true
    eval $logentry >> "$logfile" 2>&1 && break  # Was final try successful?
    logentry="[Critical] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 2 || true
    killall -qw -KILL pkcon || true
    sleep 1
    systemctl stop packagekit.service || true
    sleep 1
    systemctl start packagekit.service || true
    logentry="[Notice] Trying to install harbour-storeman despite the failed repository refresh."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 5 printf '%s\n' "$logentry" || true
    sleep 1
  fi
done
logentry="pkcon -pvy install harbour-storeman"
printf '\n%s\n' "$(date -Iseconds) [Step 2 / 2] $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 6 printf '%s\n' "[Info] Executing: $logentry" || true
# Sleeping again for a second right before the next pkcon call, because pkcon
# *rarely* fails installing a package ("not found") immediately after an
# individual repository refresh via `repo-set-data <repo> refresh-now true`.
# The following statement must be started fully detached ("double fork" /
# "daemonize": first a detached sub shell, in which pwd, umask might and
# session-id must be set anew (i.e., the execution environment), then again
# the command proper to run as new session-leader), because this script file
# will be removed in the process, which will likely fail, if it is still
# opened for executing / reading.
# It also shall always be the last command issued (WRT control-flow),
# except for the final log message.
setsid --fork /bin/sh -c '(sleep 1; i=0; while [ $i -lt 9 ] && ps -eo pid | grep -Fq "$1"; do sleep 1; i=$(expr $i + 1); done; eval $2 >> "$3" 2>&1 < /dev/null) &' sh_do_storeman-installer "$mypid" "$logentry" "$logfile" >> "$logfile" 2>&1 < /dev/null || true
# "Daemonizing" / double-forking ("SysV-style") in Shell code, (ab)using
# this interpreter instance as first fork.
# PWD and umask do not need to be set anew here, see lines 34 and 35.
logentry="[Debug] ${called}'s main script (PID: ${mypid}) finishes"
printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
exit $retc

