#!/bin/sh
set -u  # Do not use "-f" (disable pathname expansion) and "-C" (no-clobber /
# -overwrite), as this script does not potentially need that (yet).
# Also drop "-e" for now, as it helps and hinders different aspects of debugging.
#set -o pipefail  # Not used (yet), hence also dropping interpreter #!/bin/bash
#export POSIXLY_CORRECT=1  # Leave it for now, can have side-effects (positive and negative), apparently not needed (yet).
export LC_ALL=POSIX  # For details see https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_02

# Specify bash as interpreter of this script (in its first line), as this ensures
# that "-o pipefail" is available (for its use in the third line), after checking
# that bash seems to be present in mer-core at least since 2011-10-04 (see
# https://github.com/sailfishos/mer-core/bash / https://git.merproject.org/mer-core/bash )
# and consequently in SailfishOS since its beginnings (checked v1.0.0.5 per
# curl https://releases.sailfishos.org/sources/sailfish-1.0.0.5-oss.tar.bz2 | tar -tv | fgrep bash
# , as no earlier released version is available there, e.g. the first ones at
# https://coderus.openrepos.net/whitesoft/sailversion ).
# In SailfishOS releases before 4.0, /bin/sh is just a symbolic link to /bin/bash
# anyway.  Since SailfishOS 4.0, the busybox variant of ash has become the shell
# installed by default, which provides some bash compatibility (implicitly, when
# called via its bash-symlink, which is deployed by the busybox-symlinks-bash
# RPM), including "-o pipefail", but not "-o posix"; although setting
# POSIXLY_CORRECT instead seems to achive the same without compatibility issues,
# plus (when exported) also for a number of other GNU utilities.
# Nevertheless, this script is still a Bourne (not-"Again") Shell script and
# shall stay free of bashisms.

# This script is designed to be called as detached ("&") as the last statement
# of the %posttrans section (the last executed) of an RPM spec file, or manually.

# Memorise how we were called:
called="$(basename "$0")"

# If logfile is already there, update its timestamp(s), else create it:
export logfile="/var/log/${called}.log.txt"
if ! touch "$logfile"
then printf '%s\n' "[Error] Failed to touch logfile $logfile" | systemd-cat -t "$called" -p 4 || true
fi

# Prefix first output with three linebreaks, if logfile size > 0
linebreaks=""
if [ -s "$logfile" ]
then line_breaks="\n\n\n"
fi

# Provide RPM with a little time to proceed finishing the RPM transaction,
# which called this script in a detached ("&") manner, because pkcon might
# fail enqueuing a pkcon-job while an RPM transaction is unfinished.
sleep 2
# `pkcon search name` is also intended to serve as a synchronisation point,
# because most of pkcon's sub-commands wait until the package management
# backend (on SailfishOS: libzypp) is idle:
pkgname="$(pkcon -p search name "$called" | grep '^Installed ' | tr -s ' ' | cut -f 2 -d ' ' | rev | cut -f 2- -d '.' | rev | grep -m 1 "^$called-[0-9]")"

# Write first entry to logfile:
logentry="[Info] $pkgname touch'ed $logfile"
if printf "${linebreaks}%s\n" "$(date -Iseconds) $logentry" >> "$logfile"
then printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 6 || true
else printf '%s\n' "[Error] $pkgname failed to write to $logfile" | systemd-cat -t "$called" -p 4 || true
fi

# Out of occasional bad experience when pkcon is being hammered with commands,
# also prefix `pkcon repo-set-data` with a second sleep:
sleep 1
logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
printf '%s\n' "[Debug] Execute: $logentry" | systemd-cat -t "$called" -p 7 || true
if eval $logentry >> "$logfile" 2>&1
then
  # Sleeping again for a second between the two pkcon calls, because pkcon
  # *rarely* fails installing a package ("not found") immediately after an
  # individual repository refresh via `repo-set-data <repo> refresh-now true`:
  sleep 1
  export logentry="pkcon -pvy install harbour-storeman"
  printf '\n%s\n' "$(date -Iseconds) [Step 2 / 2] $logentry" >> "$logfile" || true
  printf '%s\n' "[Debug] Execute: $logentry" | systemd-cat -t "$called" -p 7 || true
  # The following statement must be started fully detached ("double fork" /
  # "daemonize": first a detached sub shell, in which pwd, umask might and
  # session-id must be set anew (i.e., the execution environment), then again
  # the command proper to run as new session-leader), because this script file
  # will be removed in the process, which will likely fail, if it is still
  # opened for executing / reading.
  # It also shall always be the last command issued (WRT control-flow).
  (eval setsid --fork $logentry >> "$logfile" 2>&1 < /dev/null) >> "$logfile" 2>&1 < /dev/null & || true
  # "Daemonizing" / double-forking in shell-style, though I did not manage for
  # the grandchild *not* to be a session leader (i.e., to fork again with a
  # single shell expression).  PWD and umask do not need to be set anew, here.
  retc=0
else
  retc=$?
  logentry="[Critical] Aborting to install harbour-storeman, because error-code $retc was returned by: $logentry"
  printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
  printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 3 || true
  sleep 1
  export logentry="pkcon -pvy remove $called"
  printf '\n%s\n' "$(date -Iseconds) [Self-removal] $logentry" >> "$logfile" || true
  printf '%s\n' "[Info] Execute: $logentry" | systemd-cat -t "$called" -p 6 || true
  (eval setsid --fork $logentry >> "$logfile" 2>&1 < /dev/null) >> "$logfile" 2>&1 < /dev/null & || true
fi
exit $retc

