#!/bin/sh
# set -u  # Do not use "-f" (disable pathname expansion) and "-C" (no-clobber /
# -overwrite), as this script does not potentially need that (yet).
# Also drop "-e" for now, as it helps and hinders different aspects of debugging.
#set -o pipefail  # Not used (yet), hence also dropping interpreter #!/bin/bash
#export POSIXLY_CORRECT=1  # Leave it for now, can have side-effects (positive and negative), apparently not needed (yet).
export LC_ALL=POSIX  # For details see https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap08.html#tag_08_02
umask 7113  # The first octal digit is ignored by most implementations
[ "$PWD" != /tmp ] || cd /tmp  # Set PWD to /tmp

# Specify bash as interpreter of this script (in its first line), as this ensures
# that "-o pipefail" is available (for its use in the third line), after checking
# that bash seems to be present in mer-core at least since 2011-10-04 (see
# https://github.com/sailfishos/mer-core/bash / https://git.merproject.org/mer-core/bash )
# and consequently in SailfishOS since its beginnings (checked v1.0.0.5 per
# curl https://releases.sailfishos.org/sources/sailfish-1.0.0.5-oss.tar.bz2 | tar -tv | fgrep bash
# , as no earlier released version is available there, e.g. the first ones at
# https://coderus.openrepos.net/whitesoft/sailversion ).
# In SailfishOS releases before 4.0, /bin/sh is just a symbolic link to /bin/bash
# anyway.  Since SailfishOS 4.0, the busybox variant of ash has become the shell
# installed by default, which provides some bash compatibility (implicitly, when
# called via its bash-symlink, which is deployed by the busybox-symlinks-bash
# RPM), including "-o pipefail", but not "-o posix"; although setting
# POSIXLY_CORRECT instead seems to achive the same without compatibility issues,
# plus (when exported) also for a number of other GNU utilities.
# Nevertheless, this script is still a Bourne (not-"Again") Shell script and
# shall stay free of bashisms.

# Memorise how we were called:
called="$(basename "$0")"
export gppid="$1"
logfile="$2"
export mypid="$$"
export ppid="$PPID"

# Test-instrumentation:
{
  echo
  echo "3. Right after starting the harbour-storeman-installer script"
  echo "umask: $(umask), pwd: $(pwd), \$PWD: $PWD, \$OLDPWD: $OLDPWD, \$SHELL: $SHELL"
  env
  echo "\$zypid: $zypid, \$ppid: $ppid, \$mypid: $mypid, \$PPID: $PPID, \$$: $$, \$!: $!"
  ps -o stat,tty,user,group,pgid,sid,ppid,pid,comm,args | head -1
  ps -eo stat,tty,user,group,pgid,sid,ppid,pid,comm,args | grep -E "$mypid|$ppid|$$|$PPID"
  echo
} >> "$logfile" 2>&1

# This script is designed to be called fully detached (by a "double fork" /
# a "daemonize") as the last statement of the %posttrans section 
# (the last executed) of an RPM spec file.
# Terminate parent, which was made session leader by `setsid --fork`:
kill "$PPID" > /dev/null 2>&1 || true

# Prefix first output with three linebreaks, if logfile size > 0
linebreaks=""
if [ -s "$logfile" ]
then linebreaks="\n\n\n"
fi

# Write first entry to logfile:
logentry="[Info] Logging to $logfile"
if printf "${linebreaks}%s\n" "$(date -Iseconds) $logentry" >> "$logfile"
then printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 6 || true
else systemd-cat -t "$called" -p 4 printf '%s\n' "[Error] $pkgname failed to write to $logfile" || true
fi

# Provide RPM with a little time to proceed finishing the RPM transaction,
# which called this script asynchronously, because pkcon might fail
# enqueuing a pkcon-job while an RPM transaction is unfinished.
i=0
maxi=60
rpmXact=running
while [ $i -lt $maxi ] && ps -eo pid | grep -Fq "$gppid"
do
  sleep 1
  count=$(expr $i + 1)
done
if [ $i -ge $maxi ]
then rpmXact=timedout
else rpmXact=finished
fi
sleep 1
# `pkcon search name` is also intended to serve as a synchronisation point,
# because most of pkcon's sub-commands wait until the package management
# backend (on SailfishOS: libzypp) is idle:
pkgname="$(pkcon -p search name "$called" | grep '^Installed ' | tr -s ' ' | cut -f 2 -d ' ' | rev | cut -f 2- -d '.' | rev | grep -m 1 "^$called-[0-9]")"

# Write $pkgname to logfile:
logentry="[Debug] Installed, now running: $pkgname"
printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true

# Out of occasional bad experience when pkcon is being hammered with
# commands, also prefix `pkcon repo-set-data` with a second sleep:
sleep 1
maxi=4  # 4 is the minimal value, which makes sense here
maxihalf=$(expr $maxi / 2)
for i in $(seq $maxi)
do
  logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
  printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
  systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
  eval $logentry >> "$logfile" 2>&1
  retc=$?
  wait=$(expr $i \* 2 + 1)
  if [ $retc = 0 ]
  then break  # Went fine
  elif [ $i = 1 ]
  then
    logentry="[Warning] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 5 || true
    logentry="[Debug] Sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -le $maxihalf ]
  then
    logentry="[Warning] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 5 || true
    logentry="[Info] Trying to terminate (i.e., sending SIGTERM to) all processes named (ID) `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
    killall -q -TERM pkcon
    sleep $wait
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  elif [ $i -lt $maxi ]
  then
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 4 || true
    logentry="[Warning] Trying to interrupt (i.e., sending SIGINT to) all processes named (ID) `pkcon`, then sleeping for $wait seconds."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    killall -q -INT pkcon
    sleep $i
    killall -q -TERM pkcon
    sleep $i
    logentry="[Info] Retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
  else
    logentry="[Error] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 4 || true
    logentry="[Warning] Trying to hang-up (i.e., sending SIGHUP to) all processes named (ID) `pkcon`, then sleeping for $i seconds and ultimately killing them."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "$logentry" || true
    killall -q -HUP pkcon
    sleep $i
    killall -qw -KILL pkcon
    sleep 1
    logentry="[Info] Final retry #$i"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "$logentry" || true
    logentry="pkcon -pv repo-set-data harbour-storeman-obs refresh-now true"
    printf '\n%s\n' "$(date -Iseconds) [Step 1 / 2] $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
    eval $logentry >> "$logfile" 2>&1 && break  # Was final try successful?
    logentry="[Critical] Failed to refresh harbour-storeman-obs repository, because error-code $retc was returned by: $logentry"
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    printf '%s\n' "$logentry" | systemd-cat -t "$called" -p 3 || true
    killall -qw -KILL pkcon
    logentry="[Warning] Scheduling harbour-storeman-installer for removal in 30 seconds, trying to install harbour-storeman despite the failed repository refresh meanwhile."
    printf '\n%s\n' "$(date -Iseconds) $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 5 printf '%s\n' "$logentry" || true
    sleep 1
    logentry="pkcon -pvy remove $called"
    printf '\n%s\n' "$(date -Iseconds) [Self-removal] $logentry" >> "$logfile" || true
    systemd-cat -t "$called" -p 6 printf '%s\n' "[Info] Scheduled for execution in 30 seconds: $logentry" || true
    setsid --fork /bin/sh -c '(kill "$PPID"; i=0; while [ $i -lt 9 ] && ps -eo pid | grep -Fq "$1"; do sleep 1; i=$(expr $i + 1); done; sleep 30; eval $2 >> "$3" 2>&1 < /dev/null) &' sh_rm_storeman-installer "$mypid" "$logentry" "$logfile" >> "$logfile" 2>&1 < /dev/null
  fi
done
logentry="pkcon -pvy install harbour-storeman"
printf '\n%s\n' "$(date -Iseconds) [Step 2 / 2] $logentry" >> "$logfile" || true
systemd-cat -t "$called" -p 7 printf '%s\n' "[Debug] Execute: $logentry" || true
# Sleeping again for a second right before the next pkcon call, because pkcon
# *rarely* fails installing a package ("not found") immediately after an
# individual repository refresh via `repo-set-data <repo> refresh-now true`.
# The following statement must be started fully detached ("double fork" /
# "daemonize": first a detached sub shell, in which pwd, umask might and
# session-id must be set anew (i.e., the execution environment), then again
# the command proper to run as new session-leader), because this script file
# will be removed in the process, which will likely fail, if it is still
# opened for executing / reading.
# It also shall always be the last command issued (WRT control-flow).
setsid --fork /bin/sh -c '(kill "$PPID"; sleep 1; i=0; while [ $i -lt 9 ] && ps -eo pid | grep -Fq "$1"; do sleep 1; i=$(expr $i + 1); done; eval $2 >> "$3" 2>&1 < /dev/null) &' sh_do_storeman-installer "$mypid" "$logentry" "$logfile" >> "$logfile" 2>&1 < /dev/null
# "Daemonizing" / double-forking ("SysV-style") in Shell code, (ab)using
# this interpreter instance as first fork.
# PWD and umask do not need to be set anew here, see line 9.

# Test-instrumentation:
{
  export cpid="${$!:-$mypid}"
  echo
  echo "4. Right before finishing the harbour-storeman-installer script"
  echo "umask: $(umask), pwd: $(pwd), \$PWD: $PWD, \$OLDPWD: $OLDPWD, \$SHELL: $SHELL"
  env
  echo "\$ppid: $ppid, \$mypid: $mypid, \$cpid: $cpid, \$PPID: $PPID, \$$: $$, \$!: $!"
  ps -o stat,tty,user,group,pgid,sid,ppid,pid,comm,args | head -1
  ps -eo stat,tty,user,group,pgid,sid,ppid,pid,comm,args | grep -E "$mypid|$cpid"
  echo
} >> "$logfile" 2>&1

exit $retc

